/**
 * Option C: Unified Extractor (AI + AJV, no deterministic bias)
 * 
 * Clean, simple unified extractor that replaces the complex Evidence-First multi-layer system.
 * Features:
 * - Single AI call with structured output (no multi-track processing)
 * - AJV validation with strict schema enforcement
 * - No deterministic heuristics or department-specific logic
 * - Clean fallback to existing plan-based system
 * - Feature flag to enable/disable (default: OFF)
 * - Zero deterministic leakage - pure AI extraction only
 */

const Ajv = require('ajv');
const addFormats = require('ajv-formats');

// Feature flag - HARD DEFAULT = false (must be explicitly enabled)
const UNIFIED_EXTRACTOR_ENABLED = process.env.UNIFIED_EXTRACTOR_ENABLED === 'true' || false;

// Import the existing plan-based system
let processWithPlanBasedSystem;
try {
  processWithPlanBasedSystem = require('./worker-enhanced').processWithPlanBasedSystem;
} catch (error) {
  console.warn('Could not load worker-enhanced.js, using fallback:', error.message);
  processWithPlanBasedSystem = async (content, params) => {
    console.log('Using fallback plan-based system');
    return {
      success: true,
      data: [],
      metadata: { processingMethod: 'fallback_plan_based' }
    };
  };
}

// Initialize AJV with strict validation
const ajv = new Ajv({ 
  strict: true,
  allErrors: true,
  removeAdditional: true, // Remove phantom fields
  useDefaults: false,
  coerceTypes: false
});
addFormats(ajv);

/**
 * Unified Extractor - Option C Implementation
 * Single AI call with structured output, AJV validation, clean fallback
 */
class UnifiedExtractor {
  constructor() {
    this.openai = null;
    this.initializeOpenAI();
  }

  initializeOpenAI() {
    try {
      const OpenAI = require('openai');
      if (process.env.OPENAI_API_KEY) {
        this.openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY
        });
      } else {
        console.warn('OpenAI API key not found - unified extractor will use fallback');
      }
    } catch (error) {
      console.warn('Failed to initialize OpenAI:', error.message);
    }
  }

  /**
   * Main processing method with feature flag check
   */
  async processWithUnifiedExtractor(htmlContent, params) {
    const startTime = Date.now();
    
    try {
      // Feature flag check - HARD DEFAULT = false
      if (!UNIFIED_EXTRACTOR_ENABLED) {
        console.log('📋 Unified extractor disabled, using plan-based system');
        return await processWithPlanBasedSystem(htmlContent, params);
      }

      console.log('🎯 Using Unified Extractor (Option C)');
      
      // Generate JSON Schema from user query
      const schema = this.generateJSONSchema(params.extractionInstructions);
      console.log('📋 Generated JSON Schema:', JSON.stringify(schema, null, 2));

      // Single AI call with structured output
      const extractedData = await this.performSingleAIExtraction(htmlContent, params, schema);
      
      // AJV validation with phantom field prevention
      const validationResult = this.validateWithAJV(extractedData, schema);
      
      if (!validationResult.valid) {
        console.warn('❌ AJV validation failed:', validationResult.errors);
        return this.fallbackToPlanBasedSystem(htmlContent, params, 'ajv_validation_failed', validationResult.errors);
      }

      const processingTime = Date.now() - startTime;
      
      return {
        success: true,
        data: validationResult.cleanData,
        metadata: {
          processingMethod: 'unified_extractor_option_c',
          unifiedExtractor: true,
          processingTime,
          schema: schema,
          validation: {
            valid: true,
            phantomFieldsRemoved: validationResult.phantomFieldsRemoved,
            originalDataLength: Array.isArray(extractedData) ? extractedData.length : 0
          },
          fallbackUsed: false
        }
      };

    } catch (error) {
      console.error('💥 Unified extractor failed:', error.message);
      return this.fallbackToPlanBasedSystem(htmlContent, params, 'unified_extractor_error', error.message);
    }
  }

  /**
   * Generate JSON Schema from natural language query
   * Pure schema generation without deterministic bias
   */
  generateJSONSchema(query) {
    const queryLower = query.toLowerCase();
    
    // Simple field inference based on common patterns (no deterministic bias)
    const fields = {};
    let hasSpecificFields = false;

    // Check for explicit field requests
    if (queryLower.includes('name') || queryLower.includes('title')) {
      fields.name = { type: 'string', description: 'Name or title' };
      hasSpecificFields = true;
    }
    
    if (queryLower.includes('description') || queryLower.includes('summary') || queryLower.includes('content')) {
      fields.description = { type: 'string', description: 'Description or content' };
      hasSpecificFields = true;
    }
    
    if (queryLower.includes('url') || queryLower.includes('link')) {
      fields.url = { type: 'string', format: 'uri', description: 'URL or link' };
      hasSpecificFields = true;
    }
    
    if (queryLower.includes('email')) {
      fields.email = { type: 'string', format: 'email', description: 'Email address' };
      hasSpecificFields = true;
    }
    
    if (queryLower.includes('phone')) {
      fields.phone = { type: 'string', description: 'Phone number' };
      hasSpecificFields = true;
    }
    
    if (queryLower.includes('price') || queryLower.includes('cost')) {
      fields.price = { type: 'string', description: 'Price or cost' };
      hasSpecificFields = true;
    }

    // For simple list queries (like "department names")
    if ((queryLower.includes('names') || queryLower.includes('list')) && 
        (queryLower.includes('department') || queryLower.includes('category'))) {
      return {
        type: 'array',
        items: { type: 'string' },
        minItems: 1,
        description: 'List of names or categories'
      };
    }

    // Default object structure if no specific fields identified
    if (!hasSpecificFields) {
      fields.name = { type: 'string', description: 'Name or identifier' };
      fields.description = { type: 'string', description: 'Description or content' };
    }

    return {
      type: 'array',
      items: {
        type: 'object',
        properties: fields,
        required: Object.keys(fields).length > 0 ? [Object.keys(fields)[0]] : ['name'],
        additionalProperties: false, // CRITICAL: prevent phantom fields
        unevaluatedProperties: false // CRITICAL: prevent phantom fields
      },
      minItems: 1
    };
  }

  /**
   * Perform single AI extraction with structured output
   * No multi-track processing - pure AI approach
   */
  async performSingleAIExtraction(htmlContent, params, schema) {
    if (!this.openai) {
      throw new Error('OpenAI not initialized - cannot perform AI extraction');
    }

    // Clean HTML content for AI processing
    const cleanContent = this.cleanHTMLForAI(htmlContent);
    
    // Build extraction prompt with strict JSON schema compliance
    const prompt = `You are a precise data extractor. Extract information from the following HTML content based on the user's request.

USER REQUEST: ${params.extractionInstructions}

HTML CONTENT:
${cleanContent}

EXTRACTION RULES:
1. Extract ONLY the data requested by the user
2. Return data in the EXACT JSON format specified by the schema
3. Do NOT add any additional fields beyond what's in the schema
4. If data is missing, omit the field entirely (don't use null/empty values)
5. Return clean, user-readable values (not raw HTML)
6. Extract ALL matching items from the content, not just the first few
7. Ensure the response is valid JSON that matches the schema exactly

REQUIRED JSON SCHEMA:
${JSON.stringify(schema, null, 2)}

Return ONLY the JSON data - no explanations or additional text.`;

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: 'You are a precise data extraction system. Return only valid JSON that exactly matches the provided schema. Never add extra fields or explanations.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        response_format: { type: 'json_object' },
        temperature: 0, // Deterministic output
        max_tokens: 4000
      });

      const content = response.choices[0].message.content;
      
      try {
        const jsonData = JSON.parse(content);
        return jsonData;
      } catch (parseError) {
        console.error('Failed to parse AI response as JSON:', content);
        throw new Error(`Invalid JSON response from AI: ${parseError.message}`);
      }

    } catch (error) {
      console.error('OpenAI API call failed:', error.message);
      throw new Error(`AI extraction failed: ${error.message}`);
    }
  }

  /**
   * Clean HTML content for AI processing
   * Remove scripts, styles, and excessive whitespace
   */
  cleanHTMLForAI(html) {
    let cleaned = html;
    
    // Remove script and style tags with content
    cleaned = cleaned.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
    cleaned = cleaned.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
    
    // Remove comments
    cleaned = cleaned.replace(/<!--[\s\S]*?-->/g, '');
    
    // Normalize whitespace
    cleaned = cleaned.replace(/\s+/g, ' ');
    
    // Truncate if too long (keep first 20k chars)
    if (cleaned.length > 20000) {
      cleaned = cleaned.substring(0, 20000) + '... [content truncated]';
    }
    
    return cleaned.trim();
  }

  /**
   * Validate extracted data with AJV
   * Strict schema enforcement with phantom field prevention
   */
  validateWithAJV(data, schema) {
    const validate = ajv.compile(schema);
    
    // Handle single array response format
    let targetData = data;
    if (data && typeof data === 'object' && !Array.isArray(data)) {
      // If AI returned an object with an array property, extract the array
      const keys = Object.keys(data);
      const arrayKey = keys.find(key => Array.isArray(data[key]));
      if (arrayKey) {
        targetData = data[arrayKey];
      } else {
        // If AI returned a single object, wrap it in an array
        targetData = [data];
      }
    }
    
    if (!Array.isArray(targetData)) {
      return {
        valid: false,
        errors: ['Data is not an array format'],
        cleanData: [],
        phantomFieldsRemoved: 0
      };
    }

    const originalLength = targetData.length;
    let phantomFieldsRemoved = 0;

    // Pre-process to remove phantom fields and count them
    const cleanedData = targetData.map(item => {
      if (typeof item !== 'object' || item === null) return item;
      
      const allowedFields = new Set(Object.keys(schema.items.properties || {}));
      const originalFields = Object.keys(item);
      const phantomFields = originalFields.filter(field => !allowedFields.has(field));
      
      if (phantomFields.length > 0) {
        phantomFieldsRemoved += phantomFields.length;
        const cleanItem = {};
        originalFields.forEach(field => {
          if (allowedFields.has(field)) {
            cleanItem[field] = item[field];
          }
        });
        return cleanItem;
      }
      
      return item;
    });

    const isValid = validate(cleanedData);
    
    return {
      valid: isValid,
      errors: isValid ? [] : validate.errors.map(err => `${err.instancePath} ${err.message}`),
      cleanData: isValid ? cleanedData : [],
      phantomFieldsRemoved,
      originalDataLength: originalLength
    };
  }

  /**
   * Clean fallback to existing plan-based system
   */
  async fallbackToPlanBasedSystem(htmlContent, params, reason, errorDetails) {
    console.log(`🔄 Falling back to plan-based system: ${reason}`);
    
    try {
      const fallbackResult = await processWithPlanBasedSystem(htmlContent, params);
      
      return {
        ...fallbackResult,
        metadata: {
          ...fallbackResult.metadata,
          processingMethod: 'plan_based_fallback_from_unified',
          unifiedExtractor: false,
          fallbackUsed: true,
          fallbackReason: reason,
          fallbackDetails: errorDetails
        }
      };
    } catch (fallbackError) {
      console.error('💥 Plan-based fallback also failed:', fallbackError);
      
      return {
        success: false,
        error: `Both unified extractor and plan-based systems failed. Unified: ${reason}, Fallback: ${fallbackError.message}`,
        data: [],
        metadata: {
          processingMethod: 'complete_failure',
          unifiedExtractor: false,
          fallbackUsed: true,
          fallbackReason: reason,
          fallbackError: fallbackError.message
        }
      };
    }
  }
}

// Create global instance
const unifiedExtractor = new UnifiedExtractor();

/**
 * Main export function - processes with unified extractor or falls back to plan-based
 */
async function processWithUnifiedExtractor(htmlContent, params) {
  return await unifiedExtractor.processWithUnifiedExtractor(htmlContent, params);
}

/**
 * Legacy compatibility - maintain existing function name
 */
async function processWithEvidenceFirst(htmlContent, params) {
  return await processWithUnifiedExtractor(htmlContent, params);
}

/**
 * Backward compatibility wrapper
 */
class EvidenceFirstProcessor {
  async processWithEvidenceFirst(htmlContent, params) {
    return await processWithUnifiedExtractor(htmlContent, params);
  }
}

module.exports = {
  processWithUnifiedExtractor,
  processWithEvidenceFirst,
  EvidenceFirstProcessor,
  UnifiedExtractor,
  UNIFIED_EXTRACTOR_ENABLED
};